"story_id","epic","title","user_role","description","business_value","priority","story_points","dependencies","acceptance_criteria","technical_tasks","definition_of_done"
"US-001","Core Features","Register Product with Automated Warranty Calculation","Consumer","As a Consumer, I want my product warranty expiry date to be automatically calculated upon registration based on the purchase date and model defaults, so that I have accurate coverage information without manual entry.","Ensures data integrity for warranty claims, reduces user entry error, and streamlines the onboarding process.","Must Have","5","[""WI-INFRA-002""]","[{""scenario"":""Successful product registration"",""given"":""A user provides valid product details including purchase date"",""when"":""The registration form is submitted to the API"",""then"":""The warranty expiry date is calculated using UTC (date-fns/Luxon), the serial number is validated against the brand regex, and the product is saved with a 201 status.""},{""scenario"":""Invalid serial number format"",""given"":""A user provides a serial number not matching the brand pattern"",""when"":""The registration is attempted"",""then"":""The system rejects the request with a 400 Bad Request and specific validation error.""}]","[""WI-BE-001: Implement Product Registration API with Warranty Calculation"",""Implement Date-fns/Luxon UTC logic"",""Setup NestJS Validation Pipes for Regex""]","[""Unit tests > 80% coverage"",""Swagger documentation updated"",""Performance P95 latency < 500ms verified""]"
"US-002","Data Management","Lock Critical Product Data Post-Service","Brand Administrator","As a Brand Administrator, I want critical product fields (Serial, Model) to be locked from editing after a service request is created, so that historical service data remains consistent and fraud is prevented.","Prevents data tampering and maintains the integrity of the audit trail for warranty claims.","Should Have","2","[""US-001""]","[{""scenario"":""Attempt to edit locked product"",""given"":""A product has an existing service request history"",""when"":""A PUT request is made to update the Serial Number"",""then"":""The system rejects the request via the Product Lock Guard.""},{""scenario"":""Edit non-critical fields"",""given"":""A product has an existing service request history"",""when"":""A PUT request is made to update the product nickname or metadata"",""then"":""The update is permitted and saved successfully.""}]","[""WI-BE-002: Implement Product Locking Mechanism"",""Develop NestJS Guard/Interceptor"",""Create UpdateProductDTO""]","[""Integration tests covering locked vs unlocked states"",""Code review passed""]"
"US-003","Core Features","Automated Geospatial Service Routing","Service Center Administrator","As a Service Center Administrator, I want incoming service requests to be automatically routed to my center based on the customer's location within my defined geofence, so that dispatching is efficient and manual assignment is minimized.","Reduces manual dispatch overhead by 90% and ensures customers are matched with the closest authorized provider.","Must Have","8","[""WI-INFRA-002""]","[{""scenario"":""Request location inside service polygon"",""given"":""A customer submits a request with coordinates inside a Service Center's defined polygon"",""when"":""The routing logic executes"",""then"":""The request is automatically assigned to that Service Center using PostGIS ST_Contains.""},{""scenario"":""Multiple matching service centers"",""given"":""Coordinates fall within multiple overlapping service areas"",""when"":""The routing logic executes"",""then"":""The system applies round-robin assignment to distribute workload evenly.""}]","[""WI-BE-003: Implement Automated Service Request Routing Logic"",""Implement PostGIS queries"",""Configure round-robin logic""]","[""Performance tests with large polygon datasets (<250ms execution)"",""Routing logic unit tested""]"
"US-004","Performance","Real-Time Technician Location Streaming","Consumer","As a Consumer, I want to see my technician's location moving in real-time on a map when they are en route, so that I know exactly when they will arrive.","Provides 'Uber-like' transparency, significantly increasing customer satisfaction and reducing 'where are you' support calls.","Must Have","8","[""WI-INFRA-001""]","[{""scenario"":""Receive location updates"",""given"":""A technician is broadcasting location data"",""when"":""The consumer is connected to the LocationHub"",""then"":""Coordinates are received with end-to-end latency of less than 2 seconds.""},{""scenario"":""Unauthorized access attempt"",""given"":""A user attempts to listen to a location stream for a ticket they do not own"",""when"":""They connect to the SignalR Hub"",""then"":""The connection is rejected based on JWT validation.""}]","[""WI-NET-001: Implement SignalR Hub for Technician Location Streaming"",""Configure Azure SignalR Service"",""Implement Redis Backplane""]","[""Load testing with 10k concurrent connections verified"",""Latency requirements met (<2s)""]"
"US-005","User Experience","Define Service Areas via Map Editor","Super Admin","As a Super Admin, I want to draw and edit service area polygons on an interactive map, so that I can visually define precise coverage zones for Service Centers.","Enables accurate and flexible definition of service territories without requiring complex coordinate data entry.","Should Have","8","[]","[{""scenario"":""Draw valid polygon"",""given"":""The admin is on the Service Area configuration page"",""when"":""They draw a closed polygon on the Mapbox interface"",""then"":""The shape is validated for closure and non-intersection, and GeoJSON is generated for export.""},{""scenario"":""Edit existing area"",""given"":""An existing polygon is loaded"",""when"":""The admin drags a vertex to a new position"",""then"":""The updated GeoJSON is captured and ready to save.""}]","[""WI-FE-001: Implement Service Area Polygon Editor (Mapbox)"",""Integrate Mapbox GL JS"",""Implement GeoJSON validation logic""]","[""Keyboard navigation for map controls enabled"",""Validated against complex polygon shapes""]"
"US-006","Core Features","Offline Technician Operations","Technician","As a Technician, I want to update job statuses and complete forms even without internet connectivity, so that I can continue working in basements or remote areas without data loss.","Ensures field operations continuity and prevents data loss, which is critical for accurate service records.","Must Have","13","[]","[{""scenario"":""Perform action offline"",""given"":""The device has no network connectivity"",""when"":""The technician submits a job completion form"",""then"":""The action is stored in the local offline queue and the UI updates optimistically.""},{""scenario"":""Sync on reconnect"",""given"":""Actions are queued locally"",""when"":""Network connectivity is restored"",""then"":""The queue automatically syncs with the server and resolves any conflicts.""}]","[""WI-MOB-003: Implement Offline Data Sync Queue"",""Setup WatermelonDB/Redux Offline"",""Implement SyncManager logic""]","[""Network transition testing passed (Online -> Offline -> Online)"",""Data consistency verified""]"
"US-007","Integration","Automated Invoice Data Extraction","Consumer","As a Consumer, I want my invoice details to be automatically extracted from an uploaded photo, so that I don't have to manually type complex product information.","Reduces friction during product registration, leading to higher completion rates and better data quality.","Should Have","5","[""WI-INFRA-001""]","[{""scenario"":""Upload valid invoice"",""given"":""A user uploads a clear PDF or image of an invoice"",""when"":""The background worker processes the file"",""then"":""Key fields (Date, Items, Prices) are extracted and returned to the user.""},{""scenario"":""Service failure resilience"",""given"":""The AI service is temporarily unavailable"",""when"":""A processing job is attempted"",""then"":""The Circuit Breaker opens, and the job is queued for retry without crashing the system.""}]","[""WI-BG-001: Implement Invoice OCR Worker with Circuit Breaker"",""Integrate Azure AI Document Intelligence"",""Implement Polly retry policies""]","[""Resilience patterns verified via integration tests"",""Dead-letter queue monitoring configured""]"
"US-008","Security","Technician Location Data Privacy","Compliance Officer","As a Compliance Officer, I want technician location history to be automatically purged after 24 hours, so that we comply with GDPR and privacy standards regarding employee monitoring.","Mitigates legal risk and ensures compliance with data privacy regulations.","Must Have","3","[""US-004""]","[{""scenario"":""Data persistence"",""given"":""Real-time location data is flowing"",""when"":""The background persistence worker runs"",""then"":""Data is batched and written to the TimescaleDB hypertable.""},{""scenario"":""Data purging"",""given"":""Location records exist older than 24 hours"",""when"":""The retention policy check runs"",""then"":""Old records are automatically dropped/deleted from the database.""}]","[""WI-NET-002: Implement Location History Persistence"",""Implement batch writing logic"",""Configure TimescaleDB retention policies""]","[""Retention policy verified in test environment"",""Write throughput performance confirmed""]"